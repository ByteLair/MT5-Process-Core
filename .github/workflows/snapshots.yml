name: Automated Repository Snapshots

on:
  workflow_run:
    workflows: ["CI/CD Pipeline", "Deploy to Production"]
    types: [completed]
    branches: [main]
  schedule:
    # Daily at 2:00 AM UTC-3 (5:00 AM UTC)
    - cron: '0 5 * * *'
  workflow_dispatch:
    inputs:
      include_logs:
        description: 'Include logs in snapshot'
        required: false
        type: boolean
        default: false
      upload_remote:
        description: 'Upload to remote storage'
        required: false
        type: boolean
        default: false

permissions:
  contents: read

jobs:
  create-snapshot:
    name: Create Repository Snapshot
    runs-on: self-hosted
    # Only run if CI/CD succeeded or if manually triggered/scheduled
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      snapshot_name: ${{ steps.snapshot.outputs.snapshot_name }}
      snapshot_size: ${{ steps.snapshot.outputs.snapshot_size }}
      snapshot_path: ${{ steps.snapshot.outputs.snapshot_path }}
    steps:
      - name: Check CI/CD Status
        if: github.event_name == 'workflow_run'
        shell: bash
        run: |
          echo "CI/CD Workflow: ${{ github.event.workflow_run.name }}"
          echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Branch: ${{ github.event.workflow_run.head_branch }}"
          echo "Commit: ${{ github.event.workflow_run.head_sha }}"

          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "‚ùå CI/CD failed - skipping snapshot creation"
            exit 1
          fi

          echo "‚úÖ CI/CD passed - proceeding with snapshot"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git bundle

      - name: Preflight checks
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Verifying environment..."
          test -d scripts/backup || { echo "‚ùå scripts/backup not found"; exit 1; }
          test -f scripts/backup/create-snapshot.sh || { echo "‚ùå create-snapshot.sh not found"; exit 1; }

          echo "üîß Setting permissions..."
          chmod +x scripts/backup/create-snapshot.sh

          echo "üìÅ Creating backup directory..."
          mkdir -p /home/felipe/backups/snapshots

          echo "‚úÖ Preflight checks complete"

      - name: Create snapshot
        id: snapshot
        shell: bash
        run: |
          set -euo pipefail

          echo "üì∏ Starting snapshot creation..."

          # Build options
          SNAPSHOT_OPTS=""

          # Include logs if requested
          if [ "${{ github.event.inputs.include_logs || 'false' }}" == "true" ]; then
            echo "üìù Including logs in snapshot"
            SNAPSHOT_OPTS="$SNAPSHOT_OPTS --full"
          fi

          # Upload to remote for scheduled runs or if explicitly requested
          if [ "${{ github.event_name }}" == "schedule" ] || [ "${{ github.event.inputs.upload_remote || 'false' }}" == "true" ]; then
            echo "‚òÅÔ∏è  Remote upload enabled"
            SNAPSHOT_OPTS="$SNAPSHOT_OPTS --remote"
          fi

          # Execute snapshot script
          echo "üöÄ Running: ./scripts/backup/create-snapshot.sh ${SNAPSHOT_OPTS}"
          ./scripts/backup/create-snapshot.sh ${SNAPSHOT_OPTS}

          # Get snapshot details
          echo "üìä Extracting snapshot information..."
          FILE=$(ls -t /home/felipe/backups/snapshots/mt5-snapshot-*.tar.gz 2>/dev/null | head -1)

          if [ -z "$FILE" ]; then
            echo "‚ùå No snapshot file found"
            exit 1
          fi

          NAME=$(basename "$FILE" .tar.gz)
          SIZE=$(du -sh "$FILE" | cut -f1)

          echo "‚úÖ Snapshot created successfully"
          echo "   Name: $NAME"
          echo "   Size: $SIZE"
          echo "   Path: $FILE"

          # Set outputs
          echo "snapshot_path=$FILE" >> "$GITHUB_OUTPUT"
          echo "snapshot_name=$NAME" >> "$GITHUB_OUTPUT"
          echo "snapshot_size=$SIZE" >> "$GITHUB_OUTPUT"

      - name: Verify snapshot integrity
        shell: bash
        run: |
          set -euo pipefail

          NAME="${{ steps.snapshot.outputs.snapshot_name }}"
          BACKUP_DIR="/home/felipe/backups/snapshots"

          echo "üîç Verifying snapshot integrity: $NAME"

          cd "$BACKUP_DIR"

          # Extract snapshot
          echo "üì¶ Extracting snapshot for verification..."
          tar xzf "${NAME}.tar.gz"

          # Verify checksums if available
          if [ -f "${NAME}/checksums.sha256" ]; then
            echo "üîê Verifying checksums..."
            cd "${NAME}"
            if sha256sum -c checksums.sha256 2>&1 | grep -q "FAILED"; then
              echo "‚ùå Checksum verification failed"
              exit 1
            fi
            echo "‚úÖ All checksums verified"
          else
            echo "‚ö†Ô∏è  No checksums file found, skipping hash verification"
          fi

      - name: Create snapshot report
        if: always()
        shell: bash
        run: |
          SNAPSHOT_NAME="${{ steps.snapshot.outputs.snapshot_name }}"
          SNAPSHOT_SIZE="${{ steps.snapshot.outputs.snapshot_size }}"

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # üì∏ Snapshot Report

          **Snapshot:** \`${SNAPSHOT_NAME}\`
          **Size:** ${SNAPSHOT_SIZE}
          **Created:** $(date)
          **Trigger:** ${{ github.event_name }}
          **Branch:** ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref_name }}
          **Commit:** ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

          ## Status
          - ‚úÖ Snapshot created successfully
          - ‚úÖ Integrity verified
          ${{ github.event_name == 'workflow_run' && '- ‚úÖ CI/CD passed before snapshot' || '' }}

          ## Location
          \`/home/felipe/backups/snapshots/${SNAPSHOT_NAME}.tar.gz\`

          ## Restore Command
          \`\`\`bash
          ./scripts/backup/restore-snapshot.sh ${SNAPSHOT_NAME}
          \`\`\`
          EOF

      - name: Cleanup old snapshots
        shell: bash
        run: |
          set -euo pipefail

          echo "üßπ Cleaning up old snapshots..."
          cd /home/felipe/backups/snapshots

          # Keep last 10 compressed snapshots
          echo "üì¶ Keeping last 10 compressed snapshots..."
          ls -t mt5-snapshot-*.tar.gz 2>/dev/null | tail -n +11 | xargs -r rm -f || true

          # Keep last 5 extracted directories
          echo "üìÅ Keeping last 5 extracted directories..."
          ls -td mt5-snapshot-*/ 2>/dev/null | tail -n +6 | xargs -r rm -rf || true

          echo "‚úÖ Cleanup complete"

          # Show remaining snapshots
          echo ""
          echo "üìä Current snapshots:"
          ls -lht mt5-snapshot-*.tar.gz 2>/dev/null | head -5 || echo "No snapshots found"

      - name: Update snapshot index
        shell: bash
        run: |
          SNAPSHOT_INDEX="/home/felipe/backups/snapshots/snapshots-index.txt"

          if [ -f "$SNAPSHOT_INDEX" ]; then
            echo "üìã Last 5 snapshots in index:"
            tail -5 "$SNAPSHOT_INDEX"
          else
            echo "‚ö†Ô∏è  No snapshot index found"
          fi

  test-restore:
    name: Test Snapshot Restore
    needs: create-snapshot
    runs-on: self-hosted
    if: ${{ github.event_name == 'schedule' }}  # Only test restore on scheduled runs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get latest snapshot
        id: latest
        shell: bash
        run: |
          # Try to get from previous job output first
          NAME="${{ needs.create-snapshot.outputs.snapshot_name }}"

          # Fallback to finding latest if not available
          if [ -z "$NAME" ]; then
            NAME=$(ls -t /home/felipe/backups/snapshots/mt5-snapshot-*.tar.gz 2>/dev/null | head -1 | xargs -I{} basename {} .tar.gz)
          fi

          if [ -z "$NAME" ]; then
            echo "‚ùå No snapshot found for testing"
            exit 1
          fi

          echo "snapshot_name=$NAME" >> "$GITHUB_OUTPUT"
          echo "üì¶ Testing snapshot: $NAME"

      - name: Test restore (dry-run)
        shell: bash
        run: |
          set -euo pipefail

          SNAPSHOT_NAME="${{ steps.latest.outputs.snapshot_name }}"
          SNAPSHOT_FILE="/home/felipe/backups/snapshots/${SNAPSHOT_NAME}.tar.gz"

          echo "üß™ Testing restore of: $SNAPSHOT_NAME"

          # Create temp directory for test
          RESTORE_DIR=$(mktemp -d)
          echo "üìÅ Temp directory: $RESTORE_DIR"

          # Extract snapshot
          echo "üì¶ Extracting snapshot..."
          tar xzf "$SNAPSHOT_FILE" -C "$RESTORE_DIR"

          SNAPSHOT_DIR="$RESTORE_DIR/$SNAPSHOT_NAME"

          # Verify snapshot contents
          echo "üîç Checking snapshot contents..."

          if [ -f "$SNAPSHOT_DIR/repository.bundle" ]; then
            echo "‚úÖ Git bundle found"

            # Verify git bundle
            echo "üîê Verifying git bundle..."
            if git bundle verify "$SNAPSHOT_DIR/repository.bundle"; then
              echo "‚úÖ Git bundle is valid"
            else
              echo "‚ùå Git bundle verification failed"
              exit 1
            fi
          else
            echo "‚ùå Git bundle not found"
            exit 1
          fi

          [ -f "$SNAPSHOT_DIR/database-full.sql.gz" ] && echo "‚úÖ Database backup found" || echo "‚ö†Ô∏è  Database backup not found"
          [ -f "$SNAPSHOT_DIR/database-mt5_trading.sql.gz" ] && echo "‚úÖ MT5 database backup found" || echo "‚ö†Ô∏è  MT5 database backup not found"
          [ -d "$SNAPSHOT_DIR/volumes" ] && echo "‚úÖ Volume backups found" || echo "‚ö†Ô∏è  Volume backups not found"
          [ -f "$SNAPSHOT_DIR/SNAPSHOT_INFO.txt" ] && echo "‚úÖ Snapshot info found" || echo "‚ö†Ô∏è  Snapshot info not found"
          [ -f "$SNAPSHOT_DIR/checksums.sha256" ] && echo "‚úÖ Checksums found" || echo "‚ö†Ô∏è  Checksums not found"

          # Cleanup
          echo "üßπ Cleaning up test directory..."
          rm -rf "$RESTORE_DIR"

          echo "‚úÖ Snapshot restore test passed"

  notify:
    name: Notify Snapshot Status
    needs: [create-snapshot, test-restore]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Create notification summary
        shell: bash
        run: |
          CREATE_STATUS="${{ needs.create-snapshot.result }}"
          TEST_STATUS="${{ needs.test-restore.result }}"

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # üìä Snapshot Workflow Summary

          ## Job Results

          | Job | Status |
          |-----|--------|
          | Create Snapshot | $( [ "$CREATE_STATUS" == "success" ] && echo "‚úÖ Success" || echo "‚ùå Failed" ) |
          | Test Restore | $( [ "$TEST_STATUS" == "success" ] && echo "‚úÖ Success" || [ "$TEST_STATUS" == "skipped" ] && echo "‚è≠Ô∏è Skipped" || echo "‚ùå Failed" ) |

          ## Details

          EOF

          if [ "$CREATE_STATUS" == "success" ]; then
            echo "‚úÖ Snapshot created successfully"
            echo "- Snapshot Name: ${{ needs.create-snapshot.outputs.snapshot_name }}"
            echo "- Snapshot Size: ${{ needs.create-snapshot.outputs.snapshot_size }}"
          else
            echo "‚ùå Snapshot creation failed"
          fi

          if [ "$TEST_STATUS" == "success" ]; then
            echo "‚úÖ Restore test passed"
          elif [ "$TEST_STATUS" == "skipped" ]; then
            echo "‚è≠Ô∏è  Restore test skipped (only runs on schedule)"
          else
            echo "‚ùå Restore test failed"
          fi
